package libs

import (
	"math"
)

const LEAST_BLOCKSIZE = 1
const (
	NODE_ROOT        int = 0
	NODE_TOPLEFT         = 1
	NODE_TOPRIGHT        = 2
	NODE_BOTTOMLEFT      = 3
	NODE_BOTTOMRIGHT     = 4
)

type QuadNode struct {
	Id            int
	IsLeaf        bool
	Width, Height int
	topleft_pnt   Vector2
	botright_pnt  Vector2

	obj []*GObject

	TopLeft     *QuadNode
	TopRight    *QuadNode
	BottomLeft  *QuadNode
	BottomRight *QuadNode
	Prev        *QuadNode
	NodeSector  int
}

func ConstructQuadTree(grid [][]int) *QuadNode {
	var construct_task func(startr int, endr int, startc int, endc int, grid [][]int, prev *QuadNode, node_sector int) *QuadNode
	construct_task = func(startr int, endr int, startc int, endc int, grid [][]int, prev *QuadNode, node_sector int) *QuadNode {
		val := grid[startr][startc]
		var isleaf = func() bool {
			for r := startr; r < endr; r++ {
				for c := startc; c < endc; c++ {
					if grid[r][c] != val {
						return false
					}
				}
			}
			return true
		}
		tlp := Vector2{X: Float(startc), Y: Float(startr)}
		brp := Vector2{X: Float(endc - 1), Y: Float(endr - 1)}
		if isleaf() {
			return &QuadNode{
				Id:           val,
				IsLeaf:       true,
				Width:        endc - startc,
				Height:       endr - startr,
				topleft_pnt:  tlp,
				botright_pnt: brp,
				Prev:         prev,
				NodeSector:   node_sector,
			}
		}
		new_node := &QuadNode{
			Id:           val,
			IsLeaf:       false,
			Width:        endc - startc,
			Height:       endr - startr,
			topleft_pnt:  tlp,
			botright_pnt: brp,
			Prev:         prev,
			NodeSector:   node_sector,
		}
		prev = new_node
		midr := startr + (endr-startr)/2
		midc := startc + (endc-startc)/2
		new_node.TopLeft = construct_task(startr, midr, startc, midc, grid, prev, NODE_TOPLEFT)
		new_node.TopRight = construct_task(startr, midr, midc, endc, grid, prev, NODE_TOPRIGHT)
		new_node.BottomLeft = construct_task(midr, endr, startc, midc, grid, prev, NODE_BOTTOMLEFT)
		new_node.BottomRight = construct_task(midr, endr, midc, endc, grid, prev, NODE_BOTTOMRIGHT)
		return new_node
	}
	return construct_task(0, len(grid), 0, len(grid[0]), grid, nil, NODE_ROOT)
}

func (self *QuadNode) append_object(new_obj *GObject) {
	self.obj = append(self.obj, new_obj)
}

func (self *QuadNode) Insert(new_obj *GObject) {
	var inBoundary = func(p Vector2) bool {
		return (p.X >= self.topleft_pnt.X && p.X <= self.botright_pnt.X &&
			p.Y >= self.topleft_pnt.Y && p.Y <= self.botright_pnt.Y)
	}
	if !inBoundary(new_obj.Pos) {
		return
	}
	tlp := self.topleft_pnt
	brp := self.botright_pnt
	if (math.Abs(float64(tlp.X-brp.X)) <= LEAST_BLOCKSIZE) &&
		math.Abs(float64(tlp.Y-brp.Y)) <= LEAST_BLOCKSIZE {
		self.append_object(new_obj)
		self.IsLeaf = true
		return
	}

	if new_obj.Pos.X < (tlp.X+brp.X)/2 { // left
		if new_obj.Pos.Y < (tlp.Y+brp.Y)/2 { // top left
			if self.TopLeft == nil {
				self.TopLeft = &QuadNode{
					topleft_pnt: Vector2{
						self.topleft_pnt.X,
						self.topleft_pnt.Y,
					},
					botright_pnt: Vector2{
						((self.topleft_pnt.X + self.botright_pnt.X + 1) / 2) - 1, // 왼쪽이기때문에 마지막 -1
						((self.topleft_pnt.Y + self.botright_pnt.Y + 1) / 2) - 1,
					},
					Width:      self.Width / 2,
					Height:     self.Height / 2,
					IsLeaf:     false,
					Id:         new_obj.Id,
					NodeSector: NODE_TOPLEFT,
					Prev:       self,
				}
			}
			self.TopLeft.Insert(new_obj)
		} else { // bottom left
			if self.BottomLeft == nil {
				self.BottomLeft = &QuadNode{
					topleft_pnt: Vector2{
						self.topleft_pnt.X,
						(self.topleft_pnt.Y + self.botright_pnt.Y + 1) / 2,
					},
					botright_pnt: Vector2{
						((self.topleft_pnt.X + self.botright_pnt.X + 1) / 2) - 1,
						self.botright_pnt.Y,
					},
					Width:      self.Width / 2,
					Height:     self.Height / 2,
					IsLeaf:     false,
					Id:         new_obj.Id,
					NodeSector: NODE_BOTTOMLEFT,
					Prev:       self,
				}
			}
			self.BottomLeft.Insert(new_obj)
		}
	} else { // right
		if new_obj.Pos.Y <= (tlp.Y+brp.Y)/2 { // top right
			if (self.TopRight == nil) || (self.TopRight.IsLeaf) {
				self.TopRight = &QuadNode{
					topleft_pnt: Vector2{
						((self.topleft_pnt.X + self.botright_pnt.X + 1) / 2),
						self.topleft_pnt.X,
					},
					botright_pnt: Vector2{
						self.botright_pnt.X,
						((self.topleft_pnt.Y + self.botright_pnt.Y + 1) / 2) - 1, // 위쪽이기 때문에 마지막 -1
					},
					Width:      self.Width / 2,
					Height:     self.Height / 2,
					IsLeaf:     false,
					Id:         new_obj.Id,
					NodeSector: NODE_TOPRIGHT,
					Prev:       self,
				}
			}
			self.TopRight.Insert(new_obj)
		} else { // bottom right
			if (self.BottomRight == nil) || (self.BottomRight.IsLeaf) {
				self.BottomRight = &QuadNode{
					topleft_pnt: Vector2{
						(self.topleft_pnt.X + self.botright_pnt.X + 1) / 2,
						(self.topleft_pnt.Y + self.botright_pnt.Y + 1) / 2,
					},
					botright_pnt: Vector2{
						self.botright_pnt.X,
						self.botright_pnt.Y,
					},
					Width:      self.Width / 2,
					Height:     self.Height / 2,
					IsLeaf:     false,
					Id:         new_obj.Id,
					NodeSector: NODE_BOTTOMRIGHT,
					Prev:       self,
				}
			}
			self.BottomRight.Insert(new_obj)
		}
	}
}

//func (self *QuadNode) SearchSector(target_obj *GObject) []*GObject {
func (self *QuadNode) SearchSector(obj *GObject) []*GObject {
	var objects []*GObject
	var lev int = 0
	self.search_task(lev, obj, self, &objects)
	return objects

}

func (self *QuadNode) search_task(lev int, target_obj *GObject, prev_node *QuadNode, objects *[]*GObject) {
	const MAX_LEVEL = 3
	var inBoundary = func(p Vector2) bool {
		return (p.X >= self.topleft_pnt.X && p.X <= self.botright_pnt.X &&
			p.Y >= self.topleft_pnt.Y && p.Y <= self.botright_pnt.Y)
	}
	if !inBoundary(target_obj.Pos) {
		return
	}
	tlp := self.topleft_pnt
	brp := self.botright_pnt
	if ( // (lev == MAX_LEVEL) ||
	math.Abs(float64(tlp.X-brp.X)) <= LEAST_BLOCKSIZE) &&
		(math.Abs(float64(tlp.Y-brp.Y)) <= LEAST_BLOCKSIZE) {
		//TODO: check near sections object
		//TODO: 지금은 상하좌우만 확인중.. 대각선 확인 필요(원형)
		sight_radius := (target_obj.Pos.Y - target_obj.SightRadius)
		if sight_radius < self.topleft_pnt.Y {
			// 위 노드로 넘어감
			obj := target_obj
			obj.Pos.Y = sight_radius
			self.TopLeft.search_task(lev-1, obj, self.Prev, objects)
		}
		if (target_obj.Pos.Y + target_obj.SightRadius) > self.botright_pnt.Y {
			// 아래 노드로 넘어감
		}
		if (target_obj.Pos.X - target_obj.SightRadius) < (self.topleft_pnt.X) {
			// 왼쪽 노드로 넘어감
		}
		if (target_obj.Pos.X + target_obj.SightRadius) > self.botright_pnt.X {
			// 오른쪽 노드로 넘어감
		}
	}

	x := target_obj.Pos.X
	y := target_obj.Pos.Y
	var near []*GObject
	if x < (tlp.X+brp.X)/2 { // left
		if y < (tlp.Y+brp.Y)/2 { // top left
			self.TopLeft.search_task(lev+1, target_obj, self, objects)
		} else { // bottom left
			self.BottomLeft.search_task(lev+1, target_obj, self, objects)
		}
	} else { // right
		if target_obj.Pos.Y <= (tlp.Y+brp.Y)/2 { // top right
			self.TopRight.search_task(lev+1, target_obj, self, objects)
		} else { // bottom right
			self.BottomRight.search_task(lev+1, target_obj, self, objects)
		}
	}
	if near != nil {
		*objects = append(*objects, near...)
	}
	return
}

func (self *QuadNode) Remove(target_obj *GObject) {

}
